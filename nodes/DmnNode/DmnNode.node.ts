import {
	NodeConnectionType,
	IExecuteFunctions,
	INodeExecutionData,
	INodeType,
	INodeTypeDescription,
	NodeOperationError,
	LoggerProxy,
	INode,
} from 'n8n-workflow';
import { decisionTable } from '@hbtgmbh/dmn-eval-js';
import { constructDmnXml } from './dmnXmlUtils';

type DmnResultData = Record<string, any>;
type DmnEvaluationResult = DmnResultData[] | DmnResultData | undefined;

function formatOutput(
	outputParams: { name: string; type: string }[],
	outputFormat: string,
	node: INode,
	decisionResult: DmnEvaluationResult,
	originalInputItem: INodeExecutionData,
	itemIndex: number
): INodeExecutionData[] {

	const originalJson = originalInputItem.json;
	let results: DmnResultData[];
	if (decisionResult === undefined) {
		results = [];
	} else if (Array.isArray(decisionResult)) {
		results = decisionResult;
	} else {
		results = [decisionResult];
	}

	if (results.length === 0) {
		switch (outputFormat) {
			case 'alwaysList':
				const emptyListJson: { [key: string]: any[] } = {};
				outputParams.forEach(param => {
					emptyListJson[param.name] = [];
				});
				return [{ json: { ...originalJson, ...emptyListJson } }];
			case 'singleOrList':
				return [{ json: { ...originalJson, ...{} } }];
			case 'rowForEach':
				return [{ json: originalJson }];
			case 'json':
				return [{ json: { ...originalJson, result: [] } }];
			default:
				throw new NodeOperationError(node, `Invalid output format selected: ${outputFormat}`, { itemIndex });
		}
	}

	switch (outputFormat) {
		case 'alwaysList': {
			const outputJson: { [key: string]: any[] } = {};
			outputParams.forEach(param => {
				outputJson[param.name] = results.map((hit: any) => hit[param.name]);
			});
			return [{ json: { ...originalJson, ...outputJson } }];
		}
		case 'singleOrList': {
			if (results.length === 1) {
				return [{ json: { ...originalJson, ...results[0] } }];
			} else {
				const outputJson: { [key: string]: any[] } = {};
				outputParams.forEach(param => {
					outputJson[param.name] = results.map((hit: any) => hit[param.name]);
				});
				return [{ json: { ...originalJson, ...outputJson } }];
			}
		}
		case 'rowForEach': {
			return results.map((hit: any) => ({ json: { ...originalJson, ...hit } }));
		}
		case 'json': {
			return [{ json: { ...originalJson, result: results } }];
		}
		default:
		throw new NodeOperationError(node, `Invalid output format selected: ${outputFormat}`, { itemIndex });
	}
}

export class DmnNode implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'Decision Model and Notation (DMN) Node',
		name: 'dmnNode',
		// eslint-disable-next-line n8n-nodes-base/node-class-description-icon-not-svg
		icon: 'file:dmn.png',
		group: ['transform'],
		version: 1,
		description: 'Executes a DMN decision table defined by rules and parameters. Supports FEEL expressions.',
		defaults: {
			name: 'DMN Node',
		},
		// eslint-disable-next-line n8n-nodes-base/node-class-description-inputs-wrong-regular-node
		inputs: [NodeConnectionType.Main, NodeConnectionType.Main],
		inputNames: ['Rules', 'Data'],
		// eslint-disable-next-line n8n-nodes-base/node-class-description-outputs-wrong
		outputs: [NodeConnectionType.Main],
		properties: [
			{
				displayName: 'Input Parameters',
				name: 'inputParameters',
				type: 'fixedCollection',
				typeOptions: {
					multipleValues: true,
				},
				placeholder: 'Add Input Parameter',
				default: {},
				description: 'Define the input parameters used in the DMN table',
				options: [
					{
						name: 'parameter',
						displayName: 'Parameter',
						values: [
							{
								displayName: 'Name',
								name: 'name',
								type: 'string',
								default: '',
								description: 'Name of the input parameter (must match context data key)',
							},
							{
								displayName: 'Type',
								name: 'type',
								type: 'options',
								options: [
									{ name: 'String', value: 'string' },
									{ name: 'Number', value: 'number' },
									{ name: 'Boolean', value: 'boolean' },
								],
								default: 'string',
								description: 'Data type of the input parameter',
							},
						],
					},
				],
			},
			{
				displayName: 'Output Parameters',
				name: 'outputParameters',
				type: 'fixedCollection',
				typeOptions: {
					multipleValues: true,
				},
				placeholder: 'Add Output Parameter',
				default: {},
				description: 'Define the output parameters generated by the DMN table',
				options: [
					{
						name: 'parameter',
						displayName: 'Parameter',
						values: [
							{
								displayName: 'Name',
								name: 'name',
								type: 'string',
								default: '',
								description: 'Name of the output parameter (key in the result object)',
							},
							{
								displayName: 'Type',
								name: 'type',
								type: 'options',
								options: [
									{ name: 'String', value: 'string' },
									{ name: 'Number', value: 'number' },
									{ name: 'Boolean', value: 'boolean' },
								],
								default: 'string',
								description: 'Data type of the output parameter',
							},
						],
					},
				],
			},
			{
				displayName: 'Hit Policy',
				name: 'hitPolicy',
				type: 'options',
				options: [
					{ name: 'UNIQUE', value: 'UNIQUE' },
					{ name: 'FIRST', value: 'FIRST' },
					{ name: 'RULE ORDER', value: 'RULE ORDER' },
					{ name: 'COLLECT', value: 'COLLECT' },
				],
				default: 'UNIQUE',
				description: 'The hit policy for the decision table',
			},
			{
				displayName: 'Output Format',
				name: 'outputFormat',
				type: 'options',
				options: [
					{ name: 'Row with All Hits (Always Lists)', value: 'alwaysList' },
					{ name: 'Row with All Hits (Single Items and Lists)', value: 'singleOrList' },
					{ name: 'Row for Each Hit', value: 'rowForEach' },
					{ name: 'JSON with Output', value: 'json' },
				],
				default: 'alwaysList',
				description: "Choose how the output results are formatted. 'alwaysList' puts all values for an output name into a list. 'singleOrList' returns single values if only one hit, otherwise lists. 'rowForEach' creates a separate n8n item for each hit. 'JSON with Output' returns the raw result array.",
			},
		]
	};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const itemsRulesGrid = this.getInputData(0);
		const itemsInputData = this.getInputData(1);
		const decisionId = 'dynamicDecision';

		if (itemsRulesGrid.length === 0) {
			throw new NodeOperationError(this.getNode(), 'Input 1 (Rules Grid) must contain at least one item with a rule object.');
		}
		const rulesGrid = itemsRulesGrid.map(item => item.json);

		const inputParams = this.getNodeParameter('inputParameters.parameter', 0, []) as { name: string; type: string; }[];
		const outputParams = this.getNodeParameter('outputParameters.parameter', 0, []) as { name: string; type: string; }[];
		const hitPolicy = this.getNodeParameter('hitPolicy', 0, 'UNIQUE') as string;
		const outputFormat = this.getNodeParameter('outputFormat', 0, 'alwaysList') as string;
		const nodeInstance = this.getNode();

		if (!inputParams || inputParams.length === 0) {
			throw new NodeOperationError(nodeInstance, 'At least one Input Parameter must be defined.');
		}
		if (!outputParams || outputParams.length === 0) {
			throw new NodeOperationError(nodeInstance, 'At least one Output Parameter must be defined.');
		}

		let dmnXmlString: string;
		try {
			dmnXmlString = constructDmnXml(rulesGrid, inputParams, outputParams, hitPolicy);
		} catch (error) {
			const errorMessage = (error instanceof Error) ? error.message : String(error);
			throw new NodeOperationError(nodeInstance, `Failed to construct DMN XML: ${errorMessage}`, { itemIndex: 0 });
		}

		let parsedDecisions: any;
		try {
			parsedDecisions = await decisionTable.parseDmnXml(dmnXmlString);
			if (!parsedDecisions || typeof parsedDecisions !== 'object' || Object.keys(parsedDecisions).length === 0) {
				throw new NodeOperationError(nodeInstance, 'Parsed DMN seems empty or invalid.', { itemIndex: 0 });
			}
		} catch (error) {
			// eslint-disable-next-line no-console
			LoggerProxy.debug("Generated DMN XML causing error:\n" + dmnXmlString);
			const errorMessage = (error instanceof Error) ? error.message : String(error);
			throw new NodeOperationError(nodeInstance, `Failed to parse generated DMN XML: ${errorMessage}`, { itemIndex: 0 });
		}

		const boundFormatOutput = formatOutput.bind(null, outputParams, outputFormat, nodeInstance);

		const allResults: INodeExecutionData[] = [];

		for (let itemIndex = 0; itemIndex < itemsInputData.length; itemIndex++) {
			const originalInputItem = itemsInputData[itemIndex];
			const context = originalInputItem.json;
			let decisionResult: DmnEvaluationResult;

			try {
				decisionResult = await decisionTable.evaluateDecision(decisionId, parsedDecisions, context);
			} catch (error) {
				const errorMessage = (error instanceof Error) ? error.message : String(error);
				throw new NodeOperationError(nodeInstance, `Error evaluating DMN for item ${itemIndex}: ${errorMessage}`, { itemIndex });
			}

			const outputData = boundFormatOutput(decisionResult, originalInputItem, itemIndex);
			allResults.push(...outputData);
		}

		return [allResults];
	}
}
